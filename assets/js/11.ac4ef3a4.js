(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{201:function(t,e,r){t.exports=r.p+"assets/img/linked-list.f40a9825.png"},238:function(t,e,r){"use strict";r.r(e);var i=r(0),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"数据结构-链表概述"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-链表概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据结构-链表概述")]),t._v(" "),i("p",[t._v("用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。")]),t._v(" "),i("ul",[i("li",[t._v("需要遍历才能查询到元素，查询慢。")]),t._v(" "),i("li",[t._v("插入元素只需断开连接重新赋值，插入快。")])]),t._v(" "),i("p",[i("img",{attrs:{src:r(201),alt:"链表"}})]),t._v(" "),i("p",[t._v("链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。")]),t._v(" "),i("h2",{attrs:{id:"_1、基本应用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1、基本应用","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、基本应用")]),t._v(" "),i("blockquote",[i("p",[t._v("主要是对链表基本概念和特性的应用，如果基础概念掌握牢靠，此类问题即可迎刃而解")])]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/print-from-tail-to-head"}},[t._v("✔️从尾到头打印链表")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/delete-repeat-node"}},[t._v("✔️删除链表中重复的节点")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/reverse-linked-list"}},[t._v("✔️反转链表")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/merge-two-sorted-link"}},[t._v("✔️合并两个有序链表")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/copy-complicated-linked-list"}},[t._v("✔️复杂链表的复制")])])]),t._v(" "),i("h2",{attrs:{id:"_2、环类题目"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2、环类题目","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、环类题目")]),t._v(" "),i("blockquote",[i("p",[t._v("环类题目即从判断一个单链表是否存在循环而扩展衍生的问题")])]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/entry-node-of-loop"}},[t._v("✔️链表中环的入口结点")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/deep-clone"}},[t._v("环形链表")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/deep-clone"}},[t._v("约瑟夫环")])])]),t._v(" "),i("h2",{attrs:{id:"_3、双指针"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3、双指针","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、双指针")]),t._v(" "),i("blockquote",[i("p",[t._v("双指针的思想在链表和数组中的题目都经常会用到，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。")])]),t._v(" "),i("ul",[i("li",[t._v("两个指针从不同位置出发：一个从始端开始，另一个从末端开始；")]),t._v(" "),i("li",[t._v("两个指针以不同速度移动：一个指针快一些，另一个指针慢一些。")])]),t._v(" "),i("blockquote",[i("p",[t._v("对于单链表，因为我们只能在一个方向上遍历链表，所以第一种情景可能无法工作。然而，第二种情景，也被称为慢指针和快指针技巧，是非常有用的。")])]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/find-first-common-node"}},[t._v("✔️两个链表的第一个公共节点")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/find-Kth-to-tail"}},[t._v("✔️链表倒数第k个节点")])]),t._v(" "),i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/deep-clone"}},[t._v("相交链表")])])]),t._v(" "),i("h2",{attrs:{id:"_4、双向链表"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4、双向链表","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、双向链表")]),t._v(" "),i("blockquote",[i("p",[t._v("双链还有一个引用字段，称为prev字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。")])]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/deep-clone"}},[t._v("扁平化多级双向链表")])])]),t._v(" "),i("h2",{attrs:{id:"_5、未归类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5、未归类","aria-hidden":"true"}},[t._v("#")]),t._v(" 5、未归类")]),t._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"/Algorithm/Linked-List/deep-clone"}},[t._v("合并两个排序的链表")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);